
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.28.1" theme-name="Stellar" theme-version="1.28.1">
  
  <meta name="generator" content="Hexo 7.1.1">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f9fafb">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  
  <title>ARMA 学习笔记 - 随便玩玩</title>

  
    <meta name="description" content="参考书：Time Series Analysis and Its Applications, 4-th Edition  基础概念 时间序列：一组随机变量按照时间顺序下标得到的序列，被称为时间序列 be defined as a collection of random variables indexed according to the order they are obtained in t">
<meta property="og:type" content="article">
<meta property="og:title" content="ARMA 学习笔记">
<meta property="og:url" content="http://bob-lytton.github.io/2024/05/08/ARMA-Learning/index.html">
<meta property="og:site_name" content="随便玩玩">
<meta property="og:description" content="参考书：Time Series Analysis and Its Applications, 4-th Edition  基础概念 时间序列：一组随机变量按照时间顺序下标得到的序列，被称为时间序列 be defined as a collection of random variables indexed according to the order they are obtained in t">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-05-08T15:35:15.000Z">
<meta property="article:modified_time" content="2024-05-10T10:35:15.179Z">
<meta property="article:author" content="Bob Lytton">
<meta property="article:tag" content="Time Series">
<meta property="article:tag" content="Machine Learning">
<meta name="twitter:card" content="summary">
  
  
  
  <meta name="keywords" content="Time Series,Machine Learning">

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.28.1">

  

  

  
</head>
<body>

<div class="l_body s:aa content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="undefined" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">随便玩玩</div><div class="sub cap">时间是朋友</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"></nav>
</div>
<div class="widgets">


<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2024/05/08/ARMA-Learning/"><span class="title">ARMA 学习笔记</span></a><a class="item title" href="/2020/08/02/golang-fundamental/"><span class="title">Go语言入门</span></a><a class="item title" href="/2024/02/11/hello-world/"><span class="title">Hello World</span></a><a class="item title" href="/2020/08/02/intern-daily/"><span class="title">每日心得</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2024-05-08T15:35:15.000Z">2024-05-08</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2024-05-10T10:35:15.179Z">2024-05-10</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>ARMA 学习笔记</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><blockquote>
<p>参考书：Time Series Analysis and Its Applications, 4-th Edition</p>
</blockquote>
<h1 id="基础概念">基础概念</h1>
<p>时间序列：一组随机变量按照时间顺序下标得到的序列，被称为时间序列 be defined as a collection of random variables indexed according to the order they are obtained in time.</p>
<p>白噪声：从不相关的随机变量中生成的时间序列被称为白噪声序列 The time series generated from uncorrelated variables is used as a model for noise in engineering applications, where it is called white noise</p>
<p>移动平均过程：对白噪声序列应用移动平均计算获得的时间序列。可以起到filter的效果</p>
<blockquote>
<p>differ from the moving average series because one particular kind of oscillatory behavior seems to predominate, producing a sinusoidal type of behavior. A number of methods exist for generating series with this quasi-periodic behavior; we illustrate a popular one based on the autoregressive model 有周期性的时序数据不是移动平均过程</p>
</blockquote>
<p>A complete description of a time series, observed as a collection of n random variables at arbitrary time points <span class="math inline">\(t_1, t_2, . . . , t_n\)</span> , for any positive integer <span class="math inline">\(n\)</span>, is provided by the joint distribution function, evaluated as the probability that the values of the series are jointly less than the <span class="math inline">\(n\)</span> constants, <span class="math inline">\(c_1, c_2, . . . , c_n\)</span> <span class="math display">\[
F_{t_1, t_2, ..., t_n}(c_1, c_2, ..., c_n) = \Pr(x_{t_1} \le c_1, x_{t_2} \le c_2, ..., x_{t_n} \le c_n)
\]</span> Although the joint distribution function describes the data completely, it is an <strong>unwieldy</strong> tool for displaying and analyzing time series data. The distribution func- tion (1.8) must be evaluated as a function of n arguments, so any plotting of the corresponding multivariate density functions is virtually impossible. 上述完整的概率分布函数只是一个模型，并不能直接使用。更有用的是下面的几个函数</p>
<p>marginal distribution functions: <span class="math display">\[
F_t(x) = P\{x_t \le x\}
\]</span> marginal density functions: <span class="math display">\[
f_t(x) = \frac{\partial F_t(x)}{\partial x}
\]</span></p>
<ul>
<li><p>期望函数（mean function）: <span class="math display">\[
\mu_{xt} = \mathrm{E}(x_t) = \int_{-\infty}^{\infty} xf_t(x)\mathrm{d}x
\]</span> <span class="math inline">\(x\)</span>指随机变量，当只讨论一个时间序列时，通常把<span class="math inline">\(\mu_{xt}\)</span>简写作<span class="math inline">\(\mu_t\)</span></p></li>
<li><p>自协方差函数（autocovariance function）: <span class="math display">\[
\gamma_x(s, t) = \mathrm{cov}(x_s, x_t) = \mathrm{E}[(x_s - \mu_s)(x_t - \mu_t)]
\]</span> 其中<span class="math inline">\(s\)</span>和<span class="math inline">\(t\)</span>是下标，<span class="math inline">\(x\)</span>是随机变量，只讨论一个时间序列时可简写为<span class="math inline">\(\gamma(s, t)\)</span>。注意自协方差有性质<span class="math inline">\(\gamma(s, t) = \gamma(t, s)\)</span>自协方差衡量同一时间序列中不同时间两点的线性相关性。平滑的序列，其自协方差会很大；不平滑的序列中，当<span class="math inline">\(s\)</span>和<span class="math inline">\(t\)</span>相隔很远时，自协方差会接近0。当自协方差<span class="math inline">\(\gamma(s, t) = 0\)</span>时，<span class="math inline">\(x_s\)</span>和<span class="math inline">\(x_t\)</span>线性不相关，但仍然有可能有其他的相关性结构。</p></li>
</ul>
<p>当<span class="math inline">\(s = t\)</span>时，自协方差退化为方差<span class="math inline">\(\gamma(t, t) = \mathrm{var}(x_t)\)</span></p>
<ul>
<li>性质：线性组合的协方差 对于两组随机变量<span class="math inline">\(\{X_j\}\)</span>和<span class="math inline">\(\{Y_k\}\)</span>，令<span class="math inline">\(U = \sum_{j=1}^m a_jX_j\)</span>，<span class="math inline">\(V=\sum_{k=1}^r b_kY_k\)</span>，则有 <span class="math display">\[
\mathrm{cov}(U, V) = \sum_{j=1}^m\sum_{k=1}^r a_jb_k\mathrm{cov}(X_j,Y_k)\\
\mathrm{var}(U) = \mathrm{cov}(U,U)
\]</span> 该公式在后面会有广泛应用。</li>
</ul>
<p>例子：MA的自协方差 以MA模型 <span class="math display">\[
v_t = \frac{1}{3}(w_{t-1}+w_t+w_{t+1})
\]</span> 为例，其自协方差为 <span class="math display">\[
\begin{align*}
\gamma(s, t) 
&amp;=  \mathrm{cov}(v_s, v_t) \\
&amp;=  \left\{ \begin{array}{ll}
            \frac{3}{9}\sigma_w^2 &amp; s = t, \\
            \frac{2}{9}\sigma_w^2 &amp; |s-t|=1, \\
            \frac{1}{9}\sigma_w^2 &amp; |s-t|=2, \\
            0 &amp; |s-t| &gt; 2
    \end{array}
    \right.
\end{align*} 
\]</span> This particular autocovariance is interesting because it <strong>only depends on the time separation or lag</strong> and not on the absolute location of the points along the series. We shall see later that this dependence suggests a mathematical model for the concept of <strong>weak stationarity</strong>.</p>
<ul>
<li><p>自相关函数（autocorrelation function, ACF） <span class="math display">\[
\rho(s, t) = \frac{\gamma(s, t)}{\sqrt{\gamma(s, s)\gamma(t, t)}}
\]</span> The ACF measures the linear predictability of the series at time <span class="math inline">\(t\)</span>, say <span class="math inline">\(x_t\)</span> , using only the value <span class="math inline">\(x_s\)</span>.</p></li>
<li><p>强稳定性（strictly stationary） <span class="math display">\[
\Pr\{x_{t_1}\le c_1, ..., x_{t_k}\le c_k\} =
\Pr\{x_{t_1+h}\le c_1, ..., x_{t_k+h}\le c_k\}
\]</span> 对所有的<span class="math inline">\(k\)</span>，<span class="math inline">\(t_1, t_2, ..., t_k\)</span>，<span class="math inline">\(c_1, c_2, ..., c_k\)</span>和<span class="math inline">\(h\)</span>都成立。 严格稳定的时间序列的任何一段数据点的概率行为和将这一段在时间上平移<span class="math inline">\(h\)</span>个单位后的数据点的概率行为相同</p></li>
</ul>
<p>推论1：强稳定的时间序列，当<span class="math inline">\(k=1\)</span>时，上式变成 <span class="math display">\[
\Pr\{x_s \le c\}=\Pr\{x_t \le c\}
\]</span> 因而，其均值<span class="math inline">\(\mu_t = \mu_s\)</span>对任意<span class="math inline">\(s, t\)</span>都成立，进而<span class="math inline">\(\mu_t\)</span><strong>是常数</strong></p>
<p>推论2：当<span class="math inline">\(k=2\)</span>时，上式可变为 <span class="math display">\[
\Pr\{x_s\le c_1, x_t\le c_2\}=\Pr\{x_{s+h}\le c_1, x_{t+h}\le c_2\}
\]</span> 进而当该时序过程存在方差时，其自协方差满足 <span class="math display">\[
\gamma(s, t) = \gamma(s+h, t+h)
\]</span> 即自协方差只取决于<span class="math inline">\(s\)</span>到<span class="math inline">\(t\)</span>的距离。</p>
<p>强稳定性的定义太强而在实际数据分析中不实用，只是作为一个理论模型而存在。</p>
<ul>
<li>弱稳定性（weak stationarity）</li>
</ul>
<p>满足强稳定性定义中的推论1（均值为常数）和推论2（自协方差只依赖于时间点之差）的性质的时间序列，被称为弱稳定的时间序列。通常称「稳定的」即是指弱稳定性。</p>
<p>在弱稳定时间序列中，均值为常数因此可写为<span class="math inline">\(\mu_t = \mu\)</span>，自协方差可转写为只与时间差相关的形式 <span class="math display">\[
\gamma(t+h, t) = \mathrm{cov}(x_{t+h}, x_t) = \mathrm{cov}(x_h, x_0) = \gamma(h, 0)
\]</span> ACF则可以改写为 <span class="math display">\[
\rho(h) = \frac{\gamma(t+h, t)}{\sqrt{\gamma(t+h, t+h)\gamma(t, t)}} = \frac{\gamma(h)}{\gamma(0)}
\]</span></p>
<ul>
<li>趋势稳定性（trend stationarity）</li>
</ul>
<p>例如<span class="math inline">\(x_t = \alpha + \beta t + y_t\)</span>，其中<span class="math inline">\(y_t\)</span>是弱稳定的时间序列，则<span class="math inline">\(\mu_{xt} = \alpha + \beta t + \mu_y\)</span>，不是与时间无关的常数，但其自协方差<span class="math inline">\(\gamma_x(h) = \mathrm{cov}(x_{t+h}, x_t) = \mathrm{E}[(x_{t+h}-\mu_{x,t+h})(x_t - \mu_{x,t})] = \mathrm{E}[(y_{t+h}-\mu_y)(y_t-\mu_y)] = \gamma_y(h)\)</span>，因此该时序模型被认为是在线性趋势下有稳定性的，这种稳定性被称为趋势稳定性。</p>
<p>对于稳定序列，其自协方差是偶函数。即 <span class="math display">\[
\gamma(h) = \gamma((t+h)-t) = \mathrm{cov}(x_{t+h}, x_t) = \mathrm{cov}(x_t, x_{t+h}) = \gamma(t - (t+h)) = \gamma(-h)
\]</span> 显然，这是因为<span class="math inline">\(\mathrm{cov}\)</span>中的两个参数是可以交换的，而稳定序列中自协方差只和两点的时间距离有关</p>
<p>估计（estimation）一般指通过采样数据计算统计指标。</p>
<ul>
<li><p>样本自协方差（sample autocovariance function） <span class="math display">\[
\hat\gamma(h) = \frac{1}{n}\sum_{t=1}^{n-h}(x_{t+h}-\bar x)(x_t - \bar x)
\]</span> 其中<span class="math inline">\(\bar x\)</span>是样本均值，<span class="math inline">\(h\)</span>是两个样本点的间隔</p></li>
<li><p>样本自相关函数（sample autocorrelation function） <span class="math display">\[
\hat\rho(h) = \frac{\hat\gamma(h)}{\hat\gamma(0)}
\]</span> 性质：样本量足够大时，如果时间序列<span class="math inline">\(x_t\)</span>是白噪声序列，则样本ACF，即<span class="math inline">\(\hat\rho_x(h), h=1,2,...,H\)</span>，其中<span class="math inline">\(H\)</span>是任意的但固定值，基本服从<span class="math inline">\(N(0, \frac{1}{n})\)</span>的正态分布。 Based on the previous result, we obtain a rough method of assessing whether peaks in <span class="math inline">\(\hat\rho(h)\)</span> are significant by determining whether the observed peak is outside the interval <span class="math inline">\(\pm2/\sqrt n\)</span> (or plus/minus two standard errors), for a white noise sequence, approximately <span class="math inline">\(95\%\)</span> of the sample ACFs should be within these limits.</p></li>
</ul>
<h1 id="时序回归和eda分析技巧">时序回归和EDA分析技巧</h1>
<p>EDA：Exploratory Data Analysis，探索性数据分析。用于初步分析数据集的统计特性，以寻找进一步分析方向或进行可视化。</p>
<h2 id="时序场景下的回归分析">时序场景下的回归分析</h2>
<p><span class="math display">\[
x_t = \beta_0 + \beta_1 z_{t_1} + ... + \beta_q z_{t_q} + w_t, w_t \sim wn(0, \sigma_w^2)
\]</span> 上述式子的实际应用中，<span class="math inline">\(w_t\)</span>实际上是误差项。上式同时包含了一个对误差项属于白噪声分布的前提假设。 - OLS (ordinary least square) - SSE (error sum of squares), SSR (regression sum of squares) - MSE (mean squared error) - <span class="math inline">\(F\)</span>-statistics - <span class="math inline">\(R^2\)</span> (coefficient of determination) - AIC, AICc - BIC (a.k.a SIC)</p>
<h2 id="eda">EDA</h2>
<p>真实数据集很可能不满足稳定性，而存在一些趋势。如何处理以构造稳定性？</p>
<h3 id="去趋势detrending">去趋势（detrending）</h3>
<p><span class="math display">\[
x_t = \mu_t + y_t
\]</span> 其中<span class="math inline">\(x_t\)</span>是观测集（即真实数据集），<span class="math inline">\(\mu_t\)</span>表示趋势，<span class="math inline">\(y_t\)</span>是一个稳定过程。强趋势往往可能使得<span class="math inline">\(y_t\)</span>被隐藏起来，因此EDA的第一步通常是移除观测集中的趋势项，得到残差序列（这个操作被称为detrending） <span class="math display">\[
\hat y_t = x_t - \hat\mu_t
\]</span> 在这里，<span class="math inline">\(\mu_t\)</span>可以是前述线性回归得到的序列，也可以是其他有趋势性的随机过程建模的序列（比如漂移随机游走 random walk with drift）</p>
<h3 id="差分differencing">差分（differencing）</h3>
<p>使用随机游走过程对<span class="math inline">\(\mu_t\)</span>建模，即 <span class="math display">\[
\mu_t = \delta + \mu_{t-1} + w_t
\]</span> 则可对<span class="math inline">\(x_t\)</span>做差分，得到 <span class="math display">\[
\begin{align*}
x_t - x_{t-1} &amp;= (\mu_t + y_t) - (\mu_{t-1} + y_{t-1}) \\
&amp;=\delta + w_t + y_t - y_{t-1}
\end{align*}
\]</span> 令<span class="math inline">\(z_t = y_t - y_{t-1}\)</span>，则得到的序列<span class="math inline">\(z_t\)</span>也是稳定序列，因为其均值为常数<span class="math inline">\(0\)</span>，且其自协方差只与延迟（lag）相关 <span class="math display">\[
\begin{align*}
\gamma_z(h) &amp;= \mathrm{cov}(z_{t+h}, z_t) = \mathrm{cov}(y_{t+h}-y_{t+h-1}, y_t-y_{t-1}) \\
&amp;= 2\gamma_y(h) - \gamma_y(h+1) - \gamma_y(h-1)
\end{align*}
\]</span> 实际上，类似地也可以证明<span class="math inline">\(x_t - x_{t-1}\)</span>也是稳定序列，这就是<strong>差分序列</strong>。</p>
<p>差分（differencing）相比去趋势（detrending）有一项优势，就是差分中没有需要估计的参数。同样也有一项劣势，即无法对前文设定的稳定序列<span class="math inline">\(y_t\)</span>作出估计。当估计<span class="math inline">\(y_t\)</span>很重要时，detrending可能是更合适的办法；而当目标只是为了调整数据获得稳定序列时，差分会更好用一些。差分在时间序列分析中有很重要的地位。</p>
<p>一阶差分的符号表示为 <span class="math display">\[
\nabla x_t = x_t - x_{t-1}
\]</span> 一阶差分可以消除线性趋势，类似的，二阶差分可以消除二次趋势（quadratic trend）<br />
p.s. 二次的 quadratic，四次的 quartic</p>
<ul>
<li><p>后移算子（backshift operator） <span class="math display">\[
Bx_t = x_{t-1}
\]</span> 其中<span class="math inline">\(B\)</span>为后移算子（也有用<span class="math inline">\(L\)</span>来指代滞后算子lag operator的，效果相同）。 <span class="math display">\[
B^k x_t = x_{t-k}\\
B^{-1}x_{t-1} = x_t
\]</span> 即<span class="math inline">\(B^{-1}\)</span>为前移算子（forward-shift operator）</p></li>
<li><p><span class="math inline">\(d\)</span>阶差分算子 <span class="math display">\[
\nabla^d = (1-B)^d
\]</span> 使用后移算子可以简便描述<span class="math inline">\(d\)</span>阶差分算子。<span class="math inline">\(d\)</span>阶差分即 <span class="math display">\[
\begin{align*}
\nabla^d x_t &amp;= (1-B)^d x_t \\
&amp;= x_t - \binom{d}{1}Bx_t + \binom{d}{2}B^2x_t -... + (-1)^dB^dx_t
\end{align*}
\]</span></p></li>
</ul>
<h2 id="平滑化smoothing或滤波">平滑化（smoothing）或滤波</h2>
<p>例子 - moving average smoother - kernel smoothing - Lowess - Smoothing splines - smoothing one series as a function of another</p>
<h1 id="arima模型">ARIMA模型</h1>
<p>Idea:</p>
<p>Classical regression is often insufficient for explaining all of the interesting dynamics of a time series. Instead, the introduction of correlation that may be generated through lagged linear relations leads to proposing the autoregressive (AR) and autoregressive moving average (ARMA) models. Adding nonstationary models to the mix leads to the autoregressive integrated moving average (ARIMA) model.</p>
<p>关键点：parameter estimation, forecasting</p>
<h2 id="ar模型">AR模型</h2>
<ul>
<li>经典回归模型 vs 自回归模型</li>
</ul>
<p>经典回归模型建立在「静态」场景上，只让因变量被独立变量的当前值所影响。在时间序列场景下，人们需要让因变量受到独立变量的过去值乃至因变量自身的过去值的影响。而如果当前状态可以完全由独立变量的过去值建模的话，就可以进行<strong>预测</strong>了。</p>
<ul>
<li>定义：自回归模型（autoregressive model） <span class="math display">\[
x_t = \phi_1 x_{t-1} + \phi_2 x_{t-2} + ... + \phi_p x_{t-p} + w_t
\]</span> 是<span class="math inline">\(p\)</span>阶自回归模型，简写做<span class="math inline">\(\mathrm{AR}(p)\)</span>。其中<span class="math inline">\(w_t \sim wn(0, \sigma_w^2)\)</span>是白噪声项，<span class="math inline">\(\phi_1, \phi_2, ..., \phi_p\)</span>是常数，且<span class="math inline">\(\phi_p \ne 0\)</span>。 在AR模型中，<span class="math inline">\(x_t\)</span>是稳定的，且可以认为均值为0。如果其均值<span class="math inline">\(\mu\)</span>不为0，则将<span class="math inline">\(x_t\)</span>用<span class="math inline">\(x_t - \mu\)</span>来替代，得到 <span class="math display">\[
x_t - \mu = \phi_1(x_{t-1}-\mu) + ... + \phi_p(x_{t-p} - \mu) + w_t
\]</span> 上式等价于 <span class="math display">\[
x_t = \alpha + \phi_1 x_{t-1} + \phi_2 x_{t-2} + ... + \phi_p x_{t-p} + w_t,\\
where\ \alpha = \mu(1-\phi_1 - ... - \phi_p)
\]</span> 这就是常见的另外一种AR模型的定义式。</li>
</ul>
<p>对自回归模型的定义式应用后移算子并稍作变形，得到下式 <span class="math display">\[
(1-\phi_1 B - \phi_2 B^2 - ... - \phi_p B^p)x_t = w_t
\]</span> 实际应用模型时，需要首先解出<span class="math inline">\(\phi_1, \phi_2, ..., \phi_p\)</span>，上式对此有重要意义。为此有如下定义：</p>
<ul>
<li>定义：自回归算子（autoregressive operator） <span class="math display">\[
\phi(B) = 1-\phi_1 B - \phi_2 B^2 - ... - \phi_p B^p
\]</span> 为自回归算子。则AR模型可重新写成<span class="math inline">\(\phi(B)x_t = w_t\)</span>.</li>
</ul>
<h3 id="ar1模型与因果性causality">AR(1)模型与因果性（causality）</h3>
<p>考虑AR(1)模型如下 <span class="math display">\[
x_t = \phi x_{t-1} + w_t
\]</span> 迭代计算可得 <span class="math display">\[
\begin{align*}
x_t &amp;= \phi x_{t-1} + w_t \\
    &amp;= \phi (\phi x_{t-2} + w_{t-1}) + w_t \\
    &amp;= \phi^2 x_{t-2} + \phi w_{t-1} + w_t \\
    &amp;=... \\
    &amp;= \phi^k x_{t-k} + \sum_{i=0}^{k-1}\phi^i w_{t-i}
\end{align*}
\]</span> - 当<span class="math inline">\(|\phi| &lt; 1\)</span>时，由于 <span class="math display">\[
\lim_{k\to\infty}\mathrm{E}\left(x_t-\sum_{j=0}^{k-1}\phi^jw_{t-j}\right)^2 = \lim_{k\to\infty}\phi^{2k}\mathrm{E}(x_{t-k}^2) = 0
\]</span> 故可以无限迭代上式，得到 <span class="math display">\[
x_t = \sum_{i=0}^\infty \phi^i w_{t-i}
\]</span> 均方收敛。其均值为 <span class="math display">\[
\mu = \mathrm{E}(x_t) = \sum_{i=0}^\infty \phi^i\mathrm{E}(w_{t-i}) = 0
\]</span> 自协方差为 <span class="math display">\[
\begin{align*}
\gamma(h) &amp;= \mathrm{cov}(x_{t+h}, x_t) = \mathrm{cov}\left[\left(\sum_{i=0}^\infty \phi^iw_{t+h-i}\right), \left(\sum_{j=0}^\infty\phi^j w_{t-j}\right)\right] \\
&amp;= \underbrace{\sum_{i=0}^{h-1}\sum_{j=0}^\infty \phi^i \phi^j\mathrm{cov}(w_{t+h-i}, w_{t-j})}_{=0} + 
\underbrace{\sum_{i=h}^\infty\sum_{j=0}^{\infty,j\ne i-h}\phi^i\phi^j\mathrm{cov}(w_{t+h-i}, w_{t-j})}_{=0} + 
\sum_{k=0}^\infty\phi^{k+h}\phi^k\mathrm{cov}(w_k, w_k)\\
&amp;=\sigma_w^2 \sum_{i=0}^\infty \phi^{h+i}\phi^i \\
&amp;=\sigma_w^2\phi^h\sum_{i=0}^\infty\phi^{2i} = \frac{\sigma_w^2\phi^h}{1-\phi^2}, \ h\ge 0.
\end{align*}
\]</span> 进而可以得到ACF的表达式如下 <span class="math display">\[
\rho(h) = \frac{\gamma(h)}{\gamma(0)} = \phi^h, \ h\ge 0
\]</span> 即<span class="math inline">\(\rho(h)\)</span>是关于<span class="math inline">\(h\)</span>的等比数列，<span class="math inline">\(\rho(h) = \phi\rho(h-1), h=1,2,...\)</span></p>
<p>一个有趣的现象是，当<span class="math inline">\(-1 &lt; \phi &lt; 0\)</span>时，得到的时间序列<span class="math inline">\(\{x_t\}\)</span>中，相邻两项呈负相关，而隔了一项后的两项（<span class="math inline">\(x_t, x_{t-2}\)</span>）呈正相关。因而此时的时序图线会很曲折。</p>
<ul>
<li>现在考虑<span class="math inline">\(|\phi| \ge 1\)</span>的情况（explosive case）</li>
</ul>
<p>当<span class="math inline">\(\phi = 1\)</span>时，<span class="math inline">\(x_t = x_{t-1}+w_t\)</span>，退化成随机游走模型， 其自协方差为<span class="math inline">\(\gamma_x(s, t) = \mathrm{cov}(x_s, x_t) = \min\{s,t\}\sigma_w^2\)</span>。因而该随机游走模型不稳定。</p>
<p>当<span class="math inline">\(|\phi| &gt; 1\)</span>时，有<span class="math inline">\(|\phi|^j \to \infty\)</span>，因此<span class="math inline">\(\sum_{j=0}^{k-1} \phi^j w_{t-j}\)</span>在<span class="math inline">\(k\to\infty\)</span>时均方不收敛，因而不能直接用前面的方式来进行后续推导。做变形如下，令<span class="math inline">\(x_{t+1}=\phi x_t+w_{t+1}\)</span>，则有 <span class="math display">\[
\begin{align*}
x_t &amp;= \phi^{-1}x_{t+1} - \phi^{-1}w_{t+1} = \phi^{-1}(\phi^{-1}x_{t+2}-\phi^{-1}w_{t+2})-\phi^{-1}w_{t+1}\\
&amp;= ... \\
&amp;= \phi^{-k}x_{t+k} - \sum_{j=1}^{k-1}\phi^{-j}w_{t+j}
\end{align*}
\]</span> 即向前迭代<span class="math inline">\(k\)</span>步，由于<span class="math inline">\(|\phi|^{-1} &lt; 1\)</span>，故该前向递推式仍然适用之前的推导，可得 <span class="math display">\[
x_t = -\sum_{j=1}^\infty \phi^{-j}w_{t+j}
\]</span> 同样可以证明该过程是稳定的。 当然，这个式子<strong>没有什么用</strong>，因为当前状态依赖于未来状态，故此情景下无法用该模型去预测未来的数据。当前状态不依赖于未来状态的时间序列被称为<strong>因果过程</strong>（causal process）。 根据上式计算自协方差得到： <span class="math display">\[
\begin{align*}
\gamma_x(h) &amp;= \mathrm{cov}(x_{t+h}, x_t) 
= \mathrm{cov}\left(-\sum_{j=1}^\infty\phi^{-j}w_{t+h+j}, -\sum_{k=1}^\infty\phi^{-k}w_{t+k} \right)\\
&amp;=\frac{\sigma_w^2\phi^{-2}\phi^{-h}}{1-\phi^{-2}}
\end{align*}
\]</span> 下面是有趣的地方了。定义下述因果过程 <span class="math display">\[
y_t = \phi^{-1}y_{t-1} + v_t
\]</span> 其中<span class="math inline">\(v_t\sim \mathrm{iid}\ \mathrm{N}(0, \sigma_w^2\phi^{-2})\)</span>为白噪声，则<span class="math inline">\(\{y_t\}\)</span>与<span class="math inline">\(\{x_t\}\)</span>随机等价（stochastically equal）。</p>
<p>如果用自回归算子来表示AR(1)过程，则有 <span class="math display">\[
\phi(B) x_t = w_t,\ where\ \phi(B) = 1-\phi B
\]</span> 又从上文得到 <span class="math display">\[
x_t = \sum_{j=0}^\infty \psi_j w_{t-j} = \psi(B)w_t
\]</span> 代入前式，于是有 <span class="math display">\[
\phi(B)\psi(B) w_t = w_t
\]</span> 即 <span class="math display">\[
\begin{align*}
&amp; (1-\phi B)(1+\psi_1 B + \psi_2 B^2 + ... + \psi_j B^j + ...) = 1 \\
\implies &amp;(1-\phi B)(1 + (\psi_1 - \phi)B + (\psi_2-\psi_1 \phi)B^2 + ... + (\psi_j-\psi_{j-1}\phi)B^j + ...) = 1
\end{align*}
\]</span> 于是有<span class="math inline">\(\psi_j = \psi_{j-1}\phi\)</span>，且<span class="math inline">\(\psi_0=1\)</span>，因此<span class="math inline">\(\psi_j = \phi^j\)</span>. 从多项式的角度看，可以定义<span class="math inline">\(\phi(B)\)</span>的逆算子<span class="math inline">\(\phi^{-1}(B)\)</span>，则有上面的推导可知 <span class="math display">\[
\phi^{-1}(B) = 1 + \phi B + \phi^2 B^2 + ... + \phi^j B^j + ... = \frac{1}{1-\phi B}
\]</span> 逆算子刚好符合多项式的性质。</p>
<p>p.s. 浅补一下泛函分析相关概念：</p>
<ul>
<li>空间：集合+距离</li>
<li>泛函：空间到数域的映射</li>
<li>算子：空间到空间的映射
<ul>
<li>线性算子：满足线性性的算子，即<span class="math inline">\(f(\alpha x + \beta y) = \alpha f(x) + \beta f(y)\)</span></li>
<li>线性算子的多项式还是个线性算子</li>
</ul></li>
</ul>
<p>p.p.s. 随机过程相关概念</p>
<ul>
<li>均方收敛：</li>
<li>随机等价：两个随机过程的有限分布都相同</li>
</ul>
<h2 id="ma模型">MA模型</h2>
<p>MA模型假设观测数据由白噪声组成。下面是<span class="math inline">\(q\)</span>阶移动平均（moving average）模型的定义，也可记为<span class="math inline">\(\mathrm{MA}(q)\)</span>： <span class="math display">\[
x_t = w_t + \theta_1 w_{t-1} + \theta_2 w_{t-2} + ... + \theta_q w_{t-q}
\]</span> 其中<span class="math inline">\(w_t\sim wn(0, \sigma_w^2)\)</span>是白噪声项（误差项），<span class="math inline">\(\theta_1, \theta_2, ..., \theta_q(\theta_q \ne 0)\)</span>是参数。</p>
<p>可以发现AR(1)模型就是一个有无限项的MA模型。</p>
<p>定义移动平均算子（moving average operator）为 <span class="math display">\[
\theta(B) = 1 + \theta_1B + \theta_2 B^2 + ... + \theta_q B^q
\]</span> 则MA模型可重新写成<span class="math inline">\(x_t = \theta(B)w_t\)</span>.</p>
<h3 id="ma1模型的非唯一性non-uniqueness与可逆性invertibility">MA(1)模型的非唯一性（non-uniqueness）与可逆性（invertibility）</h3>
<p>考虑MA(1)模型<span class="math inline">\(x_t = w_t + \theta w_{t-1}\)</span>，分别计算均值、自协方差和ACF，则有 <span class="math display">\[
\begin{align*}
&amp;\mathrm{E}(x_t) = 0\\
&amp;\gamma(h) = \left\{ \begin{array}{lr}
(1+\theta^2)\sigma_w^2 &amp; h=0,\\
\theta \sigma_w^2 &amp; h=1,\\
0 &amp; h &gt; 1,\\
\end{array}
\right.\\
&amp;\rho(h) = \left\{ \begin{array}{lr}
\frac{\theta}{1+\theta^2} &amp; h=1,\\
0 &amp; h &gt; 1,\\
\end{array}
\right.
\end{align*}
\]</span> 注意到<span class="math inline">\(\rho(1)\)</span>对<span class="math inline">\(\theta\)</span>和<span class="math inline">\(1/\theta\)</span>是相同的。例如，取<span class="math inline">\(\theta=5\)</span>，再调整一下<span class="math inline">\(\sigma_w\)</span>，可以得到两个MA(1)序列，它们的自协方差和ACF完全相同： <span class="math display">\[
x_t = w_t + \frac{1}{5}w_{t-1}, \ w_t\sim\mathrm{iid}\ N(0,25)\\
y_t = v_t + 5v_{t-1}, \ v_t\sim\mathrm{iid}\ N(0, 1)
\]</span> 因此两个序列从观测值<span class="math inline">\(x_t, y_t\)</span>上来说完全无法区分。</p>
<p>为了确定一个模型用来分析，参考AR模型的因果性，对MA模型引入了可逆性——即存在一个等价的无穷项AR模型。 将<span class="math inline">\(x_t\)</span>与<span class="math inline">\(w_t\)</span>的地位交换，重写MA模型的等式可得<span class="math inline">\(w_t = -\theta w_{t-1}+x_t\)</span>，当<span class="math inline">\(|\theta| &lt; 1\)</span>时，可以得到<span class="math inline">\(w_t = \sum_{j=0}^\infty(-\theta)^jx_{t-j}\)</span>，即为我们想要的AR表达式。</p>
<p>同样地，MA模型可以用算子表达成如下形式 <span class="math display">\[
x_t = \theta(B)w_t
\]</span> 令<span class="math inline">\(\pi(B) = \theta^{-1}(B)\)</span>，当<span class="math inline">\(\theta(B) = 1 + \theta B\)</span>时，可以得到 <span class="math display">\[
\pi(B) = \sum_{j=0}^\infty(-\theta)^jB^j
\]</span></p>
<h2 id="arma模型">ARMA模型</h2>
<p>定义如下时间序列<span class="math inline">\(\{x_t; t=0,\pm 1, \pm 2, ...\}\)</span>为<span class="math inline">\(\mathrm{ARMA}(p,q)\)</span>模型，当<span class="math inline">\(x_t\)</span>是稳定时间序列且满足 <span class="math display">\[
x_t = \phi_1 x_{t-1}+...+\phi_p x_{t-p} + w_t + \theta_1w_{t-1} + ... + \theta_qw_{t-q}
\]</span> 其中<span class="math inline">\(\phi_p\ne 0, \theta_q\ne 0\)</span>且<span class="math inline">\(\sigma_w^2 &gt; 0\)</span>. <span class="math inline">\(p\)</span>被称为自回归阶数（autoregressive order），<span class="math inline">\(q\)</span>为移动平均阶数（moving average order）。如果<span class="math inline">\(x_t\)</span>的均值<span class="math inline">\(\mu \ne 0\)</span>，则可以令<span class="math inline">\(\alpha = \mu(1-\phi_1 - ... - \phi_p)\)</span>并重写上述模型如下 <span class="math display">\[
x_t = \alpha + \phi_1 x_{t-1}+...+\phi_p x_{t-p} + w_t + \theta_1w_{t-1} + ... + \theta_qw_{t-q}
\]</span> 从而使得<span class="math inline">\(w_t\sim wn(0, \sigma_w^2)\)</span>是白噪声。</p>
<p>用算子来表示则有 <span class="math display">\[
\phi(B)x_t = \theta(B)w_t
\]</span></p>
<h3 id="过参数化over-parameterization">过参数化（over parameterization）</h3>
<p>对上述算子表示的ARMA式子左右同时乘以一个新的多项式<span class="math inline">\(\eta(B)\)</span>，得到 <span class="math display">\[
\eta(B)\phi(B)x_t = \eta(B)\theta(B)w_t
\]</span> 这样做会得到新的关于<span class="math inline">\(B\)</span>的多项式，新式子仍然满足ARMA模型的定义，然而新式子里出现了多余的参数，使得该模型<strong>过度参数化</strong>了（或者称参数冗余，parameter redundancy）。例如，考虑白噪声过程<span class="math inline">\(x_t = w_t\)</span>，将等号左右同时乘以<span class="math inline">\(\eta(B) = 1-0.5B\)</span>，得到 <span class="math display">\[
x_t = 0.5x_{t-1}-0.5w_{t-1}+w_t
\]</span> 长得像一个ARMA(1,1)模型，从而误导了人们忘记<span class="math inline">\(x_t\)</span>实际上是白噪声。</p>
<p>在实际操作中，对一个数据集用ARMA拟合时，有可能将白噪声拟合成一个ARMA模型并且参数还很显著，从而得出数据集有自相关性的错误结论。</p>
<p>p.s. 过参数化在神经网络中有时能表现得比没有过参数化的网络更好的效果(https://zhuanlan.zhihu.com/p/98649543)</p>
<h3 id="arma模型的问题与解决方法">ARMA模型的问题与解决方法</h3>
<p>从上述讨论总结出可能出现的问题有3个： - 过参数化 - AR模型部分为了稳定性而依赖于未来数据 - MA模型不唯一</p>
<p>为了解决上述问题，需要对ARMA模型的参数增加一些限制。为此首先定义AR多项式<span class="math inline">\(\phi(z)\)</span>和MA多项式<span class="math inline">\(\theta(z)\)</span>如下 <span class="math display">\[
\phi(z) = 1-\phi_1z - ... - \phi_p z^p,\ \phi_p \ne 0,\\
\theta(z) = 1 + \theta_1z + ... + \theta_q z^q,\ \theta_q\ne 0
\]</span> 其中<span class="math inline">\(z\)</span>是复数。</p>
<h4 id="针对过参数化的处理">针对过参数化的处理</h4>
<p>规定<span class="math inline">\(ARMA(p, q)\)</span>模型是最简形式，即<span class="math inline">\(\phi(z)\)</span>和<span class="math inline">\(\theta(z)\)</span>没有公因式。这样就解决了过度参数化的问题。</p>
<h4 id="针对未来依赖的处理">针对未来依赖的处理</h4>
<p>为了解决未来依赖的问题，定义ARMA模型的因果性（causality）如下： 一个ARMA(p,q)模型是causal的，如果其时间序列<span class="math inline">\(\{x_t;t=0,\pm1,\pm2,...\}\)</span>可以被写成等号同一侧的线性过程（one-sided linear process） <span class="math display">\[
x_t = \sum_{j=0}^\infty \psi_j w_{t-j} = \psi(B)w_t
\]</span> 其中<span class="math inline">\(\psi(B) = \sum_{j=0}^\infty \psi_j B^j\)</span>，且<span class="math inline">\(\sum_{j=0}^\infty|\psi_j| &lt; \infty\)</span>，并设<span class="math inline">\(\psi_0 = 1\)</span>.</p>
<p><strong>定理</strong>：ARMA模型存在因果性当且仅当<span class="math inline">\(\phi(z) \ne 0\)</span>对所有<span class="math inline">\(|z| \le 1\)</span>都成立，换言之<span class="math inline">\(\phi(z)\)</span>的根都在单位圆之外。此时<span class="math inline">\(\psi(z)\)</span>的系数可以通过下式求出 <span class="math display">\[
\psi(z) = \sum_{j=0}^\infty\psi_jz^j = \frac{\theta(z)}{\phi(z)},\ |z|\le 1.
\]</span></p>
<p>通过对AR(1)模型的讨论可以稍微理解这个结论。证明思路则是先由<span class="math inline">\(|z|\le 1\)</span>时<span class="math inline">\(\phi(z)\ne 0\)</span>来构造<span class="math inline">\(\psi(z)\)</span>的存在性，再由待定系数法证明<span class="math inline">\(\phi(z)\psi(z) = \theta(z)\)</span>，最后反证法论证<span class="math inline">\(\phi(z)\)</span>有单位圆内的根会导致<span class="math inline">\(\theta(z)\)</span>与<span class="math inline">\(\phi(z)\)</span>有公因式导致矛盾。</p>
<details class="tag-plugin colorful folding" color="dark"><summary><span>p.s. 证明如下</span></summary><div class="body"><p>设<span class="math inline">\(\phi(z)\)</span>的根为<span class="math inline">\(z_1, ..., z_p\)</span>。假设所有根都在单位圆之外，并有顺序<span class="math inline">\(1&lt;|z_1|\le|z_2|\le...\le|z_p|\)</span>。令<span class="math inline">\(|z_1| = 1+\epsilon,\ \epsilon &gt; 0\)</span>。则对任意<span class="math inline">\(|z|&lt;|z_1|=1+\epsilon\)</span>，都有<span class="math inline">\(\phi(z)\ne 0\)</span>，因此<span class="math inline">\(\phi^{-1}(z)=1/\phi(z)\)</span>存在，并且可以按幂级数展开 <span class="math display">\[\frac{1}{\phi(z)} = \sum_{j=0}^\infty a_j z^j,\ |z|&lt;1+\epsilon.\]</span> 任取<span class="math inline">\(\delta\)</span>满足<span class="math inline">\(0&lt;\delta&lt;\epsilon\)</span>，设<span class="math inline">\(z=1+\delta\)</span>，则<span class="math inline">\(\phi^{-1}(1+\delta)&lt;\infty\)</span>收敛，即 <span class="math display">\[\phi^{-1}(1+\delta) = \sum_{j=0}^\infty a_j(1+\delta)^j &lt; \infty\]</span> 于是上式中级数的每一项都有界，即存在<span class="math inline">\(c&gt;0\)</span>，<span class="math inline">\(|a_j(1+\delta)^j|&lt;c\)</span>，转写一下有<span class="math inline">\(|a_j|&lt;c(1+\delta)^j\)</span>，进而<span class="math inline">\(\sum_{j=0}^\infty|a_j|&lt;\infty\)</span>.</p><p>于是<span class="math inline">\(\phi^{-1}(B)\)</span>存在，并且可以应用于ARMA模型的等式<span class="math inline">\(\phi(B)x_t = \theta(B)w_t\)</span>两端，得到 <span class="math display">\[x_t = \phi^{-1}(B)\phi(B)x_t = \phi^{-1}(B)\theta(B)w_t\]</span> 取<span class="math inline">\(\psi(B) = \phi^{-1}(B)\theta(B)\)</span>就有 <span class="math display">\[x_t = \psi(B)w_t = \sum_{j=0}^\infty\psi_jw_{t-j}.\]</span></p><p>现在反过来，假设<span class="math inline">\(x_t\)</span>是一个因果过程，即存在如下表示 <span class="math display">\[x_t = \sum_{j=0}^\infty\psi_jw_{t-j},\ \sum_{j=0}^\infty|\psi_j|&lt;\infty.\]</span> 将上式改写成<span class="math inline">\(x_t = \psi(B)w_t\)</span>并左右同乘以<span class="math inline">\(\phi(B)\)</span>得到 <span class="math display">\[\phi(B)x_t = \phi(B)\psi(B)w_t\]</span> 又因为<span class="math inline">\(x_t\)</span>是ARMA模型，于是<span class="math inline">\(\phi(B)x_t = \theta(B)w_t\)</span>，因此 <span class="math display">\[\phi(B)\psi(B)w_t = \theta(B)w_t.\]</span> 接下来用待定系数法证明<span class="math inline">\(\phi(z)\psi(z) = \theta(z),\ |z|\le 1\)</span>。令 <span class="math display">\[a(z) = \phi(z)\psi(z) = \sum_{j=0}^\infty a_j z^j\ |z|\le 1\]</span> 则有 <span class="math display">\[\sum_{j=0}^\infty a_jw_{t-j} = \sum_{j=0}^q\theta_j w_{t-j}\]</span> 两边同乘以<span class="math inline">\(w_{t-h}, h=0,1,2,...\)</span>并计算其均值。由于<span class="math inline">\(\mathrm{E}(w_iw_j) = 0,\ i\ne j\)</span>，且两式相等则其均值相等，对比系数可得 <span class="math display">\[\begin{array}{ll}a_h = \theta_h, &amp; h=0,1,...,q,\\a_h = 0, &amp; h &gt; q.\end{array}\]</span> 从而证明了<span class="math inline">\(\phi(z)\psi(z) = a(z) = \theta(z),\ |z|\le 1\)</span>.</p><p>最后要说明当<span class="math inline">\(x_t\)</span>是因果过程时，<span class="math inline">\(\phi(z)\)</span>的根都在单位圆之外。用反证法，假设存在<span class="math inline">\(z_0\)</span>，<span class="math inline">\(|z_0|\le 1\)</span>使得<span class="math inline">\(\phi(z_0) = 0\)</span>，则前面的讨论知道<span class="math inline">\(\phi(z_0)\psi(z_0) = \theta(z_0) = 0\)</span>仍然成立。于是<span class="math inline">\(z_0\)</span>是<span class="math inline">\(\phi(z)\)</span>和<span class="math inline">\(\theta(z)\)</span>的公共根，即<span class="math inline">\(\phi(z)\)</span>和<span class="math inline">\(\theta(z)\)</span>有公因式<span class="math inline">\((1-z_0^{-1}z)\)</span>，与前面讨论规定的二者无公因式前提矛盾。从而命题得证。</p></div></details>
<h4 id="针对ma模型不唯一的处理">针对MA模型不唯一的处理</h4>
<p>对ARMA模型引入可逆性，一个ARMA(p,q)模型被称为可逆的，如果其时间序列<span class="math inline">\(\{x_t; t=0,\pm1,\pm2,...\}\)</span>可以被写成如下形式：</p>
<p><span class="math display">\[
\pi(B)x_t = \sum_{j=0}^\infty\pi_jx_{t-j} = w_t
\]</span> 其中<span class="math inline">\(\pi(B) = \sum_{j=0}^\infty\pi_jB^j\)</span>，且<span class="math inline">\(\sum_{j=0}^\infty|\pi_j|&lt;\infty\)</span>。设<span class="math inline">\(\pi_0 = 1\)</span>.</p>
<p><strong>定理</strong>：ARMA模型是可逆的当且仅当<span class="math inline">\(\theta(z)=0\)</span>的所有解<span class="math inline">\(z\)</span>都满足<span class="math inline">\(|z| &gt; 1\)</span>，即<span class="math inline">\(\theta(z)\)</span>的根都在单位圆之外。此时<span class="math inline">\(\pi(z)\)</span>的系数可以通过下式求出 <span class="math display">\[
\pi(z) = \sum_{j=0}^\infty\pi_jz^j = \frac{\phi(z)}{\theta(z)},\ |z|\le 1.
\]</span></p>
<p>通过对MA(1)的讨论同样可以初步理解这个结论，证明类似于因果性的证明。</p>
<h2 id="差分方程difference-equation">差分方程（difference equation）</h2>
<blockquote>
<p>The study of the behavior of ARMA processes and their ACFs is greatly enhanced by a basic knowledge of difference equations, simply because they are difference equations.</p>
</blockquote>
<p>假设存在一个数列<span class="math inline">\(u_0, u_1, u_2, ...\)</span>，满足 <span class="math display">\[
u_n-\alpha u_{n-1}=0,\ \alpha \ne 0,\ n=1,2,...
\]</span> 例如AR(1)模型的ACF就满足该性质 <span class="math display">\[
\rho(h) - \phi\rho(h-1)=0,\ h=1,2,...
\]</span> 上述方程叫一阶齐次（线性）差分方程（homogeneous difference equation of order 1）。容易发现该数列是等比数列，令<span class="math inline">\(u_0 = c\)</span>，则有<span class="math inline">\(u_n = \alpha^n c\)</span>.</p>
<p>关键的点在于将上述方程改写成后移算子的形式，得到<span class="math inline">\((1-\alpha B)u_n = 0\)</span>，算子对应的多项式为<span class="math inline">\(\alpha(z) = 1-\alpha z\)</span>，其根为<span class="math inline">\(z_0 = 1/\alpha\)</span>. 则通项公式可重新写作 <span class="math display">\[
u_n = \alpha^n c = (z_0^{-1})^n c
\]</span> 其中<span class="math inline">\(z_0\)</span>为特征多项式的根。</p>
<p>对于<span class="math inline">\(p\)</span>阶齐次差分方程 <span class="math display">\[
u_n - \alpha_1u_{n-1} - ... - \alpha_pu_{n-p},\ \alpha_p\ne 0,\ n=p,p+1,...
\]</span> 其特征多项式为<span class="math inline">\(\alpha(z) = 1-\alpha_1z-...-\alpha_pz^p\)</span>. 假设<span class="math inline">\(\alpha(z)\)</span>有<span class="math inline">\(r\)</span>个不同的根<span class="math inline">\(z_1, z_2, ..., z_r\)</span>，其中<span class="math inline">\(z_j\)</span>的次数为<span class="math inline">\(m_j\)</span>，则有<span class="math inline">\(m_1+m_2+...+m_r = p\)</span>. 该齐次差分方程的通解为 <span class="math display">\[
u_n = z_1^{-n}P_1(n) + z_2^{-n}P_2(n) + ... + z_r^{-n}P_r(n)
\]</span> 其中<span class="math inline">\(P_j(n)\)</span>是<span class="math inline">\(n\)</span>的<span class="math inline">\(m_j-1\)</span>次多项式，<span class="math inline">\(P_1(n),...,P_r(n)\)</span>可通过初始条件<span class="math inline">\(u_0, ..., u_{p-1}\)</span>求出来。</p>
<details class="tag-plugin colorful folding" ><summary><span>证明</span></summary><div class="body"><p>思路是先求出差分方程基础解，再由基础解线性组合得到通解。设特征多项式<span class="math inline">\(\alpha(z)\)</span>有<span class="math inline">\(k\)</span>个根，其中<span class="math inline">\(z_j\)</span>是<span class="math inline">\(r_j\)</span>重根，则 <span class="math display">\[\alpha(B)n^lz_j^{-n} = 0,\ l=0,1,...,r_j-1\]</span> 从而基础解为 <span class="math display">\[n^lz_j^{-n},\ j=1,2,...,k,\ l=0,1,...,r_j-1\]</span> 可由数学归纳法证明。</p><p>进而可以得到通解为上述基础解的线性组合，组合的系数则由初始状态唯一确定。</p><p>详细的证明略。</p></div></details>
<p>p.s. 若差分方程的特征多项式所有根都在单位圆外，则该方程任意解会随<span class="math inline">\(n\to \infty\)</span>收敛到0；若特征多项式存在单位根，则该方程有一个周期解；若特征多项式在单位圆内有根，则该方程有一个发散解（爆炸解）。</p>
<p><strong>应用例——AR模型的ACF</strong>：比如在AR(2)过程中，<span class="math inline">\(x_t = \phi_1x_{t-1}+\phi_2x_{t-2}+w_t\)</span>，则两边乘以<span class="math inline">\(x_{t-h},\ h&gt;0\)</span>，并取期望，得到方程 <span class="math display">\[
\mathrm{E}(x_tx_{t-h})=\phi_1\mathrm{E}(x_{t-1}x_{t-h})+\phi_2\mathrm{E}(x_{t-2}x_{t-h})+\underbrace{\mathrm{E}(w_tx_{t-h})}_{=0}
\]</span> 即 <span class="math display">\[
\gamma(h) = \phi_1\gamma(h-1)+\phi_2\gamma(h-2),\ h=1,2,...
\]</span> 等号两边再同时除以<span class="math inline">\(\gamma(0)\)</span>，就有 <span class="math display">\[
\rho(h)-\phi_1\rho(h-1)\phi_2\rho(h-2)=0,\ h=1,2,...
\]</span> 初始状态是<span class="math inline">\(\rho(0) = 1,\rho(1)=\rho(-1)=\phi_1/(1-\phi_2)\)</span>. 于是就可以利用差分方程比较方便地求出ACF了。</p>
<p>此外，AR多项式的复数根还会为时间序列带来周期性。 <!-- TODO: 此处添加一个python示例） --></p>
<h2 id="偏自相关函数partial-autocorrelation-pacf">偏自相关函数（partial autocorrelation, PACF）</h2>
<h2 id="arima">ARIMA</h2>

<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2024/02/11/hello-world/">Hello World</a></div></section></div>






<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">Bob Lytton</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.28.1">Stellar 1.28.1</a> 主题创建。 本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E5%9B%9E%E5%BD%92%E5%92%8Ceda%E5%88%86%E6%9E%90%E6%8A%80%E5%B7%A7"><span class="toc-text">时序回归和EDA分析技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90"><span class="toc-text">时序场景下的回归分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eda"><span class="toc-text">EDA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%BB%E8%B6%8B%E5%8A%BFdetrending"><span class="toc-text">去趋势（detrending）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%AE%E5%88%86differencing"><span class="toc-text">差分（differencing）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E6%BB%91%E5%8C%96smoothing%E6%88%96%E6%BB%A4%E6%B3%A2"><span class="toc-text">平滑化（smoothing）或滤波</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#arima%E6%A8%A1%E5%9E%8B"><span class="toc-text">ARIMA模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ar%E6%A8%A1%E5%9E%8B"><span class="toc-text">AR模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ar1%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%9B%A0%E6%9E%9C%E6%80%A7causality"><span class="toc-text">AR(1)模型与因果性（causality）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ma%E6%A8%A1%E5%9E%8B"><span class="toc-text">MA模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ma1%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%9D%9E%E5%94%AF%E4%B8%80%E6%80%A7non-uniqueness%E4%B8%8E%E5%8F%AF%E9%80%86%E6%80%A7invertibility"><span class="toc-text">MA(1)模型的非唯一性（non-uniqueness）与可逆性（invertibility）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arma%E6%A8%A1%E5%9E%8B"><span class="toc-text">ARMA模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E5%8F%82%E6%95%B0%E5%8C%96over-parameterization"><span class="toc-text">过参数化（over parameterization）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arma%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-text">ARMA模型的问题与解决方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E8%BF%87%E5%8F%82%E6%95%B0%E5%8C%96%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">针对过参数化的处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E6%9C%AA%E6%9D%A5%E4%BE%9D%E8%B5%96%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">针对未来依赖的处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%88%E5%AF%B9ma%E6%A8%A1%E5%9E%8B%E4%B8%8D%E5%94%AF%E4%B8%80%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">针对MA模型不唯一的处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E6%96%B9%E7%A8%8Bdifference-equation"><span class="toc-text">差分方程（difference equation）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%8F%E8%87%AA%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0partial-autocorrelation-pacf"><span class="toc-text">偏自相关函数（partial autocorrelation, PACF）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arima"><span class="toc-text">ARIMA</span></a></li></ol></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a><a class="buttom" onclick="util.scrollComment()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M10.46 1.25h3.08c1.603 0 2.86 0 3.864.095c1.023.098 1.861.3 2.6.752a5.75 5.75 0 0 1 1.899 1.899c.452.738.654 1.577.752 2.6c.095 1.004.095 2.261.095 3.865v1.067c0 1.141 0 2.036-.05 2.759c-.05.735-.153 1.347-.388 1.913a5.75 5.75 0 0 1-3.112 3.112c-.805.334-1.721.408-2.977.43a10.81 10.81 0 0 0-.929.036c-.198.022-.275.054-.32.08c-.047.028-.112.078-.224.232c-.121.166-.258.396-.476.764l-.542.916c-.773 1.307-2.69 1.307-3.464 0l-.542-.916a10.605 10.605 0 0 0-.476-.764c-.112-.154-.177-.204-.224-.232c-.045-.026-.122-.058-.32-.08c-.212-.023-.49-.03-.93-.037c-1.255-.021-2.171-.095-2.976-.429A5.75 5.75 0 0 1 1.688 16.2c-.235-.566-.338-1.178-.389-1.913c-.049-.723-.049-1.618-.049-2.76v-1.066c0-1.604 0-2.86.095-3.865c.098-1.023.3-1.862.752-2.6a5.75 5.75 0 0 1 1.899-1.899c.738-.452 1.577-.654 2.6-.752C7.6 1.25 8.857 1.25 10.461 1.25M6.739 2.839c-.914.087-1.495.253-1.959.537A4.25 4.25 0 0 0 3.376 4.78c-.284.464-.45 1.045-.537 1.96c-.088.924-.089 2.11-.089 3.761v1c0 1.175 0 2.019.046 2.685c.045.659.131 1.089.278 1.441a4.25 4.25 0 0 0 2.3 2.3c.515.214 1.173.294 2.429.316h.031c.398.007.747.013 1.037.045c.311.035.616.104.909.274c.29.17.5.395.682.645c.169.232.342.525.538.856l.559.944a.52.52 0 0 0 .882 0l.559-.944c.196-.331.37-.624.538-.856c.182-.25.392-.476.682-.645c.293-.17.598-.24.909-.274c.29-.032.639-.038 1.037-.045h.032c1.255-.022 1.913-.102 2.428-.316a4.25 4.25 0 0 0 2.3-2.3c.147-.352.233-.782.278-1.441c.046-.666.046-1.51.046-2.685v-1c0-1.651 0-2.837-.089-3.762c-.087-.914-.253-1.495-.537-1.959a4.25 4.25 0 0 0-1.403-1.403c-.464-.284-1.045-.45-1.96-.537c-.924-.088-2.11-.089-3.761-.089h-3c-1.651 0-2.837 0-3.762.089" clip-rule="evenodd"/><path fill="currentColor" d="M9 11a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0"/></svg><span>参与讨论</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.min.js`,
    marked: `https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js`
  }
  

</script>

<script type="text/javascript">
  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },
    
    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function(response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function(data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function(error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
  };
</script>

<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>

<!-- required -->
<script src="/js/main.js?v=1.28.1" async></script>

<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.bootcdn.net/ajax/libs/flying-pages/2.1.2/flying-pages.min.js"></script><script defer src="https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.8.4/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.min.css`,
    js: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.umd.min.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    processEscapes: true
  }
});
MathJax.Hub.Config({
  tex2jax: {
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});
MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for(i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
