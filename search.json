[{"title":"Hello World","path":"/2024/02/11/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"Go语言入门","path":"/2020/08/02/golang-fundamental/","content":"How to build 1. 安装go语言： 2. 配置与编译 2.1 配置 2.2 编译 Types 1. 主要类型 2. 类型声明 3. 接口 Array &amp; Slice &amp; Map 1. 数组(Array) 2. 切片(Slice) 3. 映射(Map) &#x2F;&#x2F; Coming soon Modules Control Advanced topics这里是一些纲要性的内容，有些有趣的话题另外有博客专门讨论。内容如果有错，欢迎提issue指正。（正在不断更新中……） How to build1. 安装go语言：去官网下载go语言，然后按照上面的步骤安装即可 2. 配置与编译2.1 配置Go语言的几个重要的环境变量：GOPATH、GOROOT GOPATH：go语言拉取依赖的下载路径，GOPATH下应该有3个文件夹：bin, pkg, src GOROOT：一般为go语言的安装路径 2.2 编译 如果是要运行单个go代码，可以运行go run &lt;filename.go&gt; 如果要编译一个用go写的项目，在项目的根目录下运行go build即可 Types1. 主要类型Go语言的主要类型有 int int8 int16 int32 int64 float float16 float32 float64 complex byte string此外每种type都有对应的指针类型 Go语言支持结构体(struct)、接口(interface)与自定义类型自定义类型可以与原生类型一样，但是允许定义方法(method，一种需要类型实例调用的函数)，而原生类型无法自定义方法 12type int MyTypefunc (m MyType) myfunc() 零值(Zero value)Go语言为每个类型都规定了一个零值，在提到类型的时候，就不得不提每个类型的零值是什么。int类的零值就是$0$，float类的零值为$0.0$，string类的零值为&quot;&quot;，此外所有的指针、以及结构体等复杂一点的类型的零值为nil。 强制类型转换使用类型名加括号，就像调用函数一样。例： 12a := 12 // a is an int or int32b := int64(a) // b is an int64 2. 类型声明 Go语言中的变量有两种声明方式 12var a stringb := &quot;this is a string&quot; 上述变量a和b都是string，其中:=称为隐式声明，仅当这个变量名在这个作用域下第一次出现时需要，其变量类型是由所赋的值所决定的。当然如果是int的话，会默认为int（即int32），而如果要使用int64则需要强转。 Go的类型声明遵循var var_name type的顺序，可以看做是后缀表达式（而C风格的类型声明相当于中缀表达式）。后缀表达式的好处是在函数与指针嵌套定义的时候非常清晰。例如 1func Myfunc(func(int, string) []*byte, func(func(int), string) func()) *func(int) error 3. 接口Go语言中的接口(interface)也是一种类型，它定义了一系列方法，实现了这些方法的任何类型都等价于实现了这个接口，而不用显式声明。例如 1234567// fmt/pring.gotype State interface &#123; Write(b []byte) (n int, err error) Width() (wid int, ok bool) Precision() (prec int, ok bool) Flag(c int) bool&#125; 但是如果想要让一个类型实现一个接口，就必须实现这个接口里的所有方法 Array &amp; Slice &amp; Map1. 数组(Array)Go语言中的数组是固定长度的，在声明的时候就要确定好。例如 1var p = [5]int&#123;1,2,3,4,5&#125; 数组在Go语言中直接使用的场景不多，更多的是作为切片(slice)的隐含实现。切片在Go语言编程中十分普遍。 2. 切片(Slice)(参考：Go Slices: usage and internals) Slice可以通过对array进行切片操作得到，也可以对直接声明与初始化。每个slice都是对一个underlying array的引用。因此修改了underlying array就会修改所有引用其中元素的slice。切片是可变长度的，并且支持append, slice操作，十分灵活。 初始化：有两种初始化方式，第一种是直接指定值，第二种是使用make函数来初始化。注意在使用make初始化时，元素会被初始化成对应类型的零值。12var p = []int&#123;1,2,3,4,5&#125; // p = &#123;1,2,3,4,5&#125;q := make([]int, 5) // q = &#123;0,0,0,0,0&#125; 切片操作：slice有长度(length)和容量(capacity)两个属性，分别可以调用len(p)和cap(p)来查看。Go语言中array可以进行切片，切片得到的是一个slice；slice也可以继续切片，仍然得到slice类型的实例。例如12var p = []int&#123;1,2,3,4,5&#125;q := p[2:4] // q = &#123;3,4&#125;，不包含下标为4的元素 注意切片是对underlying array的引用，切片的切片也是对同一个underlying array的引用，因此改变切片时会改变underlying array，可能改变其他切片。例如123456789p := [7]int&#123;1,2,3,4,5,6,7&#125;q := p[2:7] // now q = &#123;3,4,5,6,7&#125;r := p[1:5] // now r = &#123;2,3,4,5&#125;s := q[1:4] // now s = &#123;4,5,6&#125;r[2] = 10// now q = &#123;3,10,5,6,7&#125;// now r = &#123;2,3,10,5&#125;// now s = &#123;10,5,6&#125;// now p = &#123;1,2,3,10,5,6,7&#125; append操作：类似于python的list.append和C++ STL里的vector&lt;T&gt;::push_back，追加元素在指定的slice后面Go语言中的追加元素很有意思，如果有两个不同的slice是从同一个slice那里追加不同的元素得到的，则append会为这两个slice各分配一个新的underlying array，并且与上一个slice也不同12345678910p := [3]int&#123;1,2,3&#125;s := append(p[:], 4,5,6) // append方法可以追加一列元素，按照参数顺序追加，append只能对切片操作// s = &#123;1,2,3,4,5,6&#125;s = append(s, 7) // s = &#123;1,2,3,4,5,6,7&#125;r := append(s, 7) // r = &#123;1,2,3,4,5,6,7,7&#125;r[1] = 10 // now r = &#123;1,10,3,4,6,7,7&#125;, // s = &#123;1,10,3,4,5,6,7&#125;, // p = &#123;1,2,3&#125;，// 这里r与s是同一个underlying array的引用 123456789p := [3]int&#123;1,2,3&#125;s := append(p[:], 4,5,6)r := append(s, 7)a := append(s, 8)r[1] = 10// now r = &#123;1,10,3,4,5,6,7&#125;, // a = &#123;1,2,3,4,5,6,8&#125;, // s = &#123;1,2,3,4,5,6&#125;，// 可以看到只改变了r 比较：slice只能喝nil进行比较，即判断一个slice是否为空 (问题：如何查看和比较两个slice的underlying array？) 3. 映射(Map)Map，即存储键值对的结构。Go语言中的map也是采用散列来存储和索引键，类似于python中的dict。例： 1m := map[string]int 其中方括号内为键的类型，之后紧跟的是值的类型。Map的零值是nil。 Map支持插入(insert)、获取(retrieve)和删除(delete)等操作。 插入：1m[key] = elem 获取：1elem = m[key] 删除：1delete(m, key) 此外map还可以测试key是否存在，只要在查找时用两个变量来接收返回值即可，后一个是bool类型1elem, ok := m[key] 当ok = true时，说明key存在；否则key不在m中，此时elem为map对应值类型的零值。 Functions 函数也可以被当作value传给其他操作 Go语言支持内嵌函数(closure)，例如：1234567func adder() func(int) int &#123; sum := 0 return func(x int) int &#123; sum += x return sum &#125;&#125; 实现了一个加法器（相当于python里的一个实现了__call__方法的加法类）","tags":["Coding"],"categories":["Golang"]},{"title":"每日心得","path":"/2020/08/02/intern-daily/","content":"2020年7月8日，我到北京字节跳动的飞书团队入职实习做后端开发。在这里开一个文档来记录一下实习过程中的心得体会。这里的内容主要是实习过程中的一些随笔札记，所以记得比较细碎，也不会有什么文章结构。此外因为有些内容涉及公司内部信息，所以并不会放到自己的博客上来。看起来就像是隔了好几天没有记东西一样。欢迎感兴趣的人共同交流。 如果有想法，可以在博客的留言区（如果有的话）留言，或者直接去github的repo上提issue。 20&#x2F;7&#x2F;21 有API的尽量用API，不要自己实现 当然用API的时候也要看清楚API适用的场景，这可能和API内部实现方法有关 例子：在使用golang给url添加query的时候，建议使用net&#x2F;url包内的方法，而不要自己手动fmt.Sprintf(&quot;%s?xx=%s&quot;, path, queryValue)这样，因为这里的queryValue需要进行url.QueryEscape处理，而url包内的方法包含了这一处理过程。 这里蕴含了标准化操作流程的思想，可以减少bug的产生 serverless概念： serverless不是no server，只是用户注意力不在server上 serverless &#x3D; FaaS + BaaS FaaS：Function as a Service（函数服务） BaaS：Backend as a Service 20&#x2F;7&#x2F;22 三机房部署 在三个互相联网的机房部署一个服务，可以在一个机房宕机或者一条链路断开时仍然维持正常服务。比双机房稳定性更强 开发-发布模式： 分支开发-分支发布 主干开发-分支发布 分支开发-主干发布 主干开发-主干发布 全主干开发（Trunk Based Development）：在remote端不维护分支。这种模式假设提交者提交的代码都是bug-free的，是对开发者的乐观预期。 微服务 二方包 go的包import是直接引用源码 Redis Tutorial学习感想： 先学会有哪些操作，然后去了解自己操作的是什么，然后去更深入地了解redis的内部架构 Exception的处理： 要分析出异常的可能原因，哪些原因下抛出的异常需要服务继续work，哪些是fatal必须要停止服务 遭受攻击 服务器内部出错 代码bug 其他问题？ 20&#x2F;7&#x2F;23 go语言新初始化一个error的方法： errors.New() fmt.Errorf() logrus.Errorf() logrus.WithError(err).Errorf()，其中func (l *Logger) WithError(err error)在logger的一条entry里添加了error的字段 关于代码调试，找到一篇不错的blog：https://blog.codingnow.com/2018/05/ineffective_debugger.html git pull和git pull rebase 20&#x2F;7&#x2F;26 k8s：kubernetes的简写，一种开源的集群管理系统 debug的感想： 多打log leader有一次说过：当你负责某个oncall，而某天半夜被叫起来处理问题的时候，你没办法找其他任何人，但你又要把问题解决。同情一下那个时候的你，现在就多打点log吧 当然log打太多了也有副作用：占用存储太大。有同事在前公司遇到过打log把服务器打爆的情况 对bug有猜想一定要通过log或者复现来证实它 开发复杂的程序，一定要先有清晰的架构，并整理成文档 所以我经常看见有同事画功能分层 20&#x2F;7&#x2F;27 提出需求后要进行需求的拆解，接口也要讨论清楚 搞清楚应用的场景，以及自己要做什么 不能完全依赖运行代码来debug，有时候代码上线非常慢，如果最后只是因为一个个小错误就要不断地重新上线是非常浪费时间的。所以要养成良好的代码习惯，写代码的时候要时刻清醒自己在写什么，不能在熟悉的地方全凭肌肉记忆，复制粘贴的代码一定要仔细检查。 ssh进入bash终端后自动执行的是.bash_profile，要想执行.bashrc就要在.bash_profile里面调用 别人的代码是个很好的学习途径。（又叫最佳实践，团队里最好收集整理一下） 20&#x2F;7&#x2F;28 环境变量在容器里很重要 代码上线后，测试的时候要弄清楚自己测的是不是新版的代码 20&#x2F;7&#x2F;29 技术债：不良的代码习惯导致的可维护性差的代码段，这种代码在开发中写起来比较简便，上线快，但是后期会成为很大的累赘，就像债务一样，越欠越多，是个隐患。 Web编程里重要的调试手段就是直接看web请求抓包，因为API就是web请求本身 go的单元测试： 写法：在同一个包的路径下，写一个*_test.go文件 用法：在包路径下，运行go test即可，可通过go help test查看更多用法。 Web session和Cookie的概念 20&#x2F;7&#x2F;30 Cookie的SameSite属性 二分查找不能查找无序序列 这样说起来似乎很trivial，但是当二分查找被写进API的时候就要注意 例子：go语言的sort.Search()就是一个二分查找，使用前要注意被查找的数组是否有序 20&#x2F;7&#x2F;31 Hook的定义 为解决问题而查阅资料时，最好先脑内推理一下，有一个对solution的猜想，然后沿着这个猜想的思路去找证据（被mentor教做人了） 上下文：用来查找调用链，比较适合高并发的场景。一个方法要带context参数调用下游方法时，这个context参数应当来自它的上游方法，由此则形成了一条链。 20&#x2F;8&#x2F;3 实习怎么才能长进？ 除了熟悉业务流程，还要在上班时间之外去学习深究遇到的新东西，只是这确实很累啊","tags":["Bytedance"],"categories":["Intern"]},{"title":"about","path":"/about/index.html","content":"北京某大学的学生 本科就要毕业了"}]